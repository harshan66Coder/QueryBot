<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>CSV/SQLite + Gemini Tool</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/sql.js/1.5.0/sql-wasm.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.4.1/papaparse.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <style>
    body { font-family: sans-serif; margin: 20px; }
    textarea { width: 100%; height: 60px; }
    table, th, td { border: 1px solid #ccc; border-collapse: collapse; padding: 4px; }
    canvas { max-width: 800px; margin-top: 10px; }
  </style>
</head>
<body>
  <h2>Upload File (CSV or SQLite)</h2>
  <input type="file" id="fileInput"><br><br>

  <label>Description of file:</label><br>
  <textarea id="desc"></textarea><br>

  <label>Generated example question:</label><br>
  <textarea id="exampleQ"></textarea><br>
  <button id="askExample">Use that question</button>

  <hr>
  <h2>Ask a Data Table Question</h2>
  <textarea id="question"></textarea><br>
  <button id="askBtn">Get Table & Download CSV</button>
  <br><br>

  <h2>Ask a Chart Question</h2>
  <textarea id="chartQuestion"></textarea><br>
  <button id="chartQueryBtn">Generate Chart from Question</button>
  <div id="result"></div>

  <script>
    const GEMINI_API_KEY = ' '; // testing purpose you can use the gemini api - key 
    const GEMINI_MODEL = "gemini-2.5-flash";
    let SQL, db, dbReady = false, tableData = "";

    async function geminiPrompt(promptText) {
      const res = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/${GEMINI_MODEL}:generateContent?key=${GEMINI_API_KEY}`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ contents: [{ parts: [{ text: promptText }] }] })
      });
      const data = await res.json();
      return data?.candidates?.[0]?.content?.parts?.[0]?.text || 'No response';
    }

    initSqlJs({ locateFile: file => `https://cdnjs.cloudflare.com/ajax/libs/sql.js/1.5.0/${file}` }).then(SQLlib => {
      SQL = SQLlib;
      db = new SQL.Database();
      dbReady = true;
    });

    document.getElementById('fileInput').onchange = async e => {
      if (!dbReady) return alert("SQL engine still loading...");
      const file = e.target.files[0];
      if (!file) return;

      const ext = file.name.split('.').pop().toLowerCase();
      if (!['csv', 'sqlite', 'db'].includes(ext)) {
        alert('Only CSV or SQLite (.sqlite/.db) files are supported.');
        return;
      }

      if (ext === 'sqlite' || ext === 'db') {
        const buf = await file.arrayBuffer();
        db = new SQL.Database(new Uint8Array(buf));
      } else {
        const text = await file.text();
        const parsed = Papa.parse(text, { header: true });
        const headers = parsed.meta.fields;
        const rows = parsed.data.filter(row => Object.values(row).some(val => val !== ""));

        tableData = `Columns: ${headers.join(', ')}\n` + rows.slice(0, 10).map(r => JSON.stringify(r)).join('\n');

        db.run(`DROP TABLE IF EXISTS data`);
        db.run(`CREATE TABLE data (${headers.map(c => `"${c}" TEXT`).join(', ')})`);
        const stmt = db.prepare(`INSERT INTO data VALUES (${headers.map(() => '?').join(',')})`);
        rows.forEach(row => {
          stmt.bind(headers.map(h => row[h]));
          stmt.step();
          stmt.reset();
        });
        stmt.free();
      }

      const desc = await geminiPrompt(`You are given the following table data:\n\n${tableData}\n\nDescribe what kind of data this table contains.`);
      document.getElementById('desc').value = desc;

      const exampleQ = await geminiPrompt(`Based on the following description, generate a simple question a user might ask:\n\n${desc}`);
      document.getElementById('exampleQ').value = exampleQ;
    };

    document.getElementById('askExample').onclick = () => {
      document.getElementById('question').value = document.getElementById('exampleQ').value;
    };

    async function getSchemaText() {
      const schemaRes = db.exec("SELECT name FROM sqlite_master WHERE type='table'");
      const tables = schemaRes.map(r => r.values.map(v => v[0])).flat();
      let schemaText = '';
      tables.forEach(t => {
        const tableInfo = db.exec(`PRAGMA table_info(${t})`);
        const columns = tableInfo[0].values.map(row => row[1] + ' (' + row[2] + ')').join(', ');
        schemaText += `Table \"${t}\": ${columns}\n`;
      });
      return schemaText;
    }

    async function runLLMQuery(question, chartMode = false) {
      const schema = await getSchemaText();
      const sqlPrompt = `You are an expert in SQLite. Given this schema:\n${schema}\n\nAnswer this question:\n\"${question}\"\n\nProvide a valid SQLite query only, no explanation.`;
      let sql = await geminiPrompt(sqlPrompt);
      sql = sql.replace(/```(?:sqlite)?|```/g, '').trim(); 

      let res;
      try {
        res = db.exec(sql);
      } catch (err) {
        document.getElementById('result').innerHTML = `<b>Error:</b> ${err.message}<br><pre>${sql}</pre>`;
        return;
      }

      if (!res || res.length === 0) {
        document.getElementById('result').textContent = 'No results.';
        return;
      }

      const cols = res[0].columns;
      const vals = res[0].values;

      let html = '<table><tr>' + cols.map(h => `<th>${h}</th>`).join('') + '</tr>';
      vals.forEach(row => {
        html += '<tr>' + row.map(v => `<td>${v}</td>`).join('') + '</tr>';
      });
      html += '</table>';
      document.getElementById('result').innerHTML = html;

      if (!chartMode) {
        const csv = [cols.join(','), ...vals.map(r => r.join(','))].join('\n');
        html += '<button id="downloadCsv">Download CSV</button>';
        document.getElementById('result').innerHTML += html;
        document.getElementById('downloadCsv').onclick = () => {
          const a = document.createElement('a');
          a.href = URL.createObjectURL(new Blob([csv], { type: 'text/csv' }));
          a.download = 'result.csv';
          a.click();
        };
        return;
      }

      const labelIndex = cols.findIndex((_, i) => typeof vals[0][i] === 'string');
      const valueIndex = cols.findIndex((_, i) => i !== labelIndex && !isNaN(parseFloat(vals[0][i])));
      if (labelIndex === -1 || valueIndex === -1) return;

      const labels = vals.map(r => r[labelIndex]);
      const data = vals.map(r => parseFloat(r[valueIndex]) || 0);

      document.getElementById('result').innerHTML += '<canvas id="myChart"></canvas>';
      const ctx = document.getElementById('myChart').getContext('2d');
      new Chart(ctx, {
        type: 'bar',
        data: {
          labels,
          datasets: [{
            label: `${cols[valueIndex]} by ${cols[labelIndex]}`,
            data,
            backgroundColor: '#4a90e2'
          }]
        },
        options: {
          responsive: true,
          scales: {
            y: {
              beginAtZero: true
            }
          }
        }
      });
    }

    document.getElementById('askBtn').onclick = () => {
      const q = document.getElementById('question').value.trim();
      if (!q) return alert("Enter a valid question.");
      runLLMQuery(q, false);
    };

    document.getElementById('chartQueryBtn').onclick = () => {
      const q = document.getElementById('chartQuestion').value.trim();
      if (!q) return alert("Enter a valid chart question.");
      runLLMQuery(q, true);
    };
  </script>
</body>
</html>